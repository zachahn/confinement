#!/usr/bin/env ruby
# frozen_string_literal: true

if File.exist?(File.expand_path("../.git", __dir__))
  lib = File.expand_path("../lib", __dir__)
  $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
end

require "optparse"
require "pathname"

require "confinement/version"

module Confinement
  class CLI
    def self.subcommands
      @subcommands ||= {
        "init" => Init.new,
      }
    end

    def self.script_name
      @script_name ||= File.basename(__FILE__)
    end

    def optparser
      @optparser ||= OptionParser.new do |opts|
        opts.banner = "Usage: #{CLI.script_name} [options] [subcommand [options]]"

        opts.on("--version", "Print version (#{Confinement::VERSION})") do
          puts Confinement::VERSION
          exit
        end

        opts.on("-h", "--help", "Prints this help message") do
        end
      end
    end

    def call(argv)
      optparser.order!(argv)
      subcommand_name = argv.shift

      if subcommand_name.nil?
        puts(optparser)
        exit
      end

      if !self.class.subcommands.key?(subcommand_name)
        $stderr.puts("#{CLI.script_name}: `#{subcommand_name}` is not valid command")
        $stderr.puts
        $stderr.puts(optparser)
        exit(1)
      end

      subcommand = self.class.subcommands.fetch(subcommand_name)
      subcommand.optparser.parse!(argv)
      subcommand.call(argv)
    end

    private

    class Init
      def optparser
        @options ||= {}
        @optparser ||= OptionParser.new do |opts|
          opts.banner = "Usage: #{CLI.script_name} init [directory]"

          opts.on("--force", "Write files without prompting") do
            @force = true
          end

          opts.on("--skip", "Skip files without prompting") do
            @skip = true
          end

          opts.on("-h", "--help", "Prints this help message") do
            puts opts
            exit
          end
        end
      end

      def call(argv)
        if argv.size != 1
          puts optparser
          exit
        end

        require "open3"

        root = Pathname.new(argv.first).expand_path

        templates = DATA.read.split(/^==> /)[1..-1]
        templates = templates.filter_map do |template|
          path, *body = template.lines
          body = body.join("")

          [Pathname.new(File.join(root, path.strip)), body.strip + "\n"]
        end

        templates
          .map { |path, _| path.dirname }
          .uniq
          .each { |path| mkdir(path, root) }

        templates.each do |path, body|
          write(path, body, root)
        end

        Dir.chdir(root) do
          run(["yarn", "init", "--yes"])

          run(["yarn", "add", "--dev", "parcel@nightly"])
        end
      end

      private

      def run(command)
        status("exec", command.join(" "))
        Open3.capture2(*command)
      end

      def write(path, body, root)
        relpath = path.relative_path_from(root.dirname)

        if path.exist?
          if @skip
            status("skip", relpath)
          elsif @force
            status("force", relpath)
            path.write(body)
          elsif yes?("overwrite #{path}?")
            status("overwrite", relpath)
            path.write(body)
          else
            status("skip", relpath)
          end
        else
          status("write", relpath)
          path.write(body)
        end
      end

      def mkdir(dir, root)
        if dir.exist?
          status("exist", dir.relative_path_from(root.dirname))
        else
          status("mkdir", dir.relative_path_from(root.dirname))
          dir.mkdir
        end
      end

      def status(action, object)
        space = 12 - action.size
        puts "    #{action}#{" " * space}#{object}"
      end

      def yes?(question)
        print "#{question} (y/N) "
        answer = $stdin.gets

        return false if answer.nil?

        /^y/i.match?(answer)
      end
    end
  end
end

Confinement::CLI.new.call(ARGV.dup)

__END__
==> boot.rb
require "confinement"

Confinement.root = __dir__

Confinement.site = Confinement::Builder.new(
  root: Confinement.root,
  assets: "assets",
  contents: "contents",
  layouts: "layouts",
  config: {
    index: "index.html",
  }
)

==> build.rb
require_relative "boot"

using Confinement::Easier

Confinement.site.contents do |contents, layouts, dest|
  dest["/"] = Confinement::Content.new(
    layout: layouts.join("default.html.erb"),
    input_path: contents.join("index.html.erb"),
    renderers: [Confinement::Renderer::Erb.new]
  )
end

Confinement.site.assets do |assets, dest|
  dest["/assets/application.js"] = Confinement::Asset.new(
    input_path: assets.join("application.js"),
    entrypoint: true,
  )

  dest["/assets/application.css"] = Confinement::Asset.new(
    input_path: assets.join("application.css"),
    entrypoint: false,
  )
end

Confinement.site.layouts do |layouts, dest|
  dest[layouts.join("default.html.erb")] = Confinement::Layout.new(
    renderers: [Confinement::Renderer::Erb.new]
  )
end

==> write.rb
require_relative "build"

Confinement::Publish
  .new(Confinement.site)
  .write(Confinement.root.join("public"))

==> assets/application.js
import "./application.css";

==> assets/application.css

==> layouts/default.html.erb

==> contents/index.html.erb


